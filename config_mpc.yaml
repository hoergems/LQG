# Verbose output
verbose: False

# Number of paths which have to be generated by RRT to evaluate (0 => wait for timeout)
num_generated_paths: 0

# For the simplest toy problem. Use a linear path between the start and goal state
use_linear_path: True

# Number of simulation runs for the best found path
num_simulation_runs: 10

# Dimension of the workspace (2 = 2D, 3 = 3D)
workspace_dimension: 2

# Maximum angular velocity of the joints (in rad/sec)
max_velocity: 2.0

# The joint control rate
control_rate: 30.0

# The initial joint angles (has to be consistent with the number of links)
init_joint_angles: [0.0, 0.0, 0.0]

# The goal position of the end effector
goal_position: [0.0, 3.0, 0.0]

# The radius around the goal position to define the end effector's goal area
goal_radius: 0.04

#Number of bins for the histograms
num_bins: 201

# The minimum joint state covariance
min_covariance: 0.0

# The maximum joint state covariance
max_covariance: 0.02

# The number of covariance steps
covariance_steps: 5

# The observation covariance
observation_covariance: 0.001

# Path evaluation weights
# Weight for the collision probability
w1: 1.0

# Weight for the end effector covariance trace
w2: 0.0

# Reward params
discount_factor: 1.0

# Penalty for crashing into an obstacle
illegal_move_penalty: 100.0

# Penalty for taking a step
step_penalty: 1.0

# Reward for reaching a terminal state
exit_reward: 1000.0

joint_constraint: 3.14159

stop_when_terminal: True

# Number of samples drawn from the state distribution at step i 
# in order to evaluate collision probability
sample_size: 50

######## MPC parameters ############

# The number of steps a path gets evaluated for
horizon: -1

max_num_steps: 200

# The maximum number of steps a path gets executed before replanning
num_execution_steps: 20

# Maximum allowed planning time per step
timeout: 1.0



